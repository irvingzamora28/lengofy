name: Deploy to VPS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      seed:
        description: 'Run database seeding'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      rebuild:
        description: 'Force rebuild containers (use when dependencies changed)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_BUILDKIT: 1

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: mbstring, pdo, pdo_mysql, zip, exif, pcntl

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Cache Composer dependencies
        uses: actions/cache@v3
        with:
          path: ~/.composer/cache
          key: composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: composer-

      - name: Cache Bun dependencies
        uses: actions/cache@v3
        with:
          path: ~/.bun/install/cache
          key: bun-${{ hashFiles('**/bun.lockb') }}
          restore-keys: bun-

      - name: Install PHP dependencies
        run: composer install --no-dev --optimize-autoloader

      - name: Install Bun dependencies
        run: bun install --frozen-lockfile

      - name: Build assets
        run: bun run build

      - name: Generate optimized Docker image
        run: |
          # Create optimized .dockerignore
          cat > .dockerignore <<'DIEOF'
          .git
          .github
          node_modules
          .env
          storage/logs/*
          storage/framework/cache/*
          storage/framework/sessions/*
          storage/framework/views/*
          storage/app/public/*
          bootstrap/cache/*
          vendor/bin/phpunit
          tests/
          docker-compose*.yml
          Dockerfile.*
          README.md
          DIEOF
          sed -i 's/^[[:space:]]*//' .dockerignore

      - name: Copy repository contents via scp
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "."
          target: "/var/www/html"
          rm: true
          exclude: |
            node_modules
            .git
            .github
            tests

      - name: Deploy to VPS
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 300s
          script: |
            cd /var/www/html

            # Setup SSL with Let's Encrypt if domain is configured
            if [ "${{ secrets.DOMAIN_NAME }}" != "" ]; then
              echo "Setting up SSL for ${{ secrets.DOMAIN_NAME }}..."

              # Install certbot if not present
              if ! command -v certbot &> /dev/null; then
                apt-get update && apt-get install -y certbot
              fi

              # Generate SSL certificate if not exists
              if [ ! -f "/etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem" ]; then
                echo "Generating SSL certificate..."
                # Stop anything on port 80 so certbot standalone can bind
                docker compose -f docker-compose.prod.yml down 2>/dev/null || true
                systemctl stop nginx 2>/dev/null || true
                certbot certonly --standalone -d ${{ secrets.DOMAIN_NAME }} --agree-tos --non-interactive --register-unsafely-without-email

                # Verify certificate was created
                if [ ! -f "/etc/letsencrypt/live/${{ secrets.DOMAIN_NAME }}/fullchain.pem" ]; then
                  echo "❌ SSL certificate generation failed"
                  exit 1
                fi
              fi

              # Setup auto-renewal cron (renew in standalone mode, restart nginx container after)
              if ! crontab -l 2>/dev/null | grep -q certbot; then
                (crontab -l 2>/dev/null; echo "0 3 * * * certbot renew --standalone --pre-hook 'docker stop lengofy-nginx || true' --post-hook 'docker start lengofy-nginx || true' --quiet") | crontab -
              fi

              echo "✅ SSL setup completed"
            else
              echo "⚠️ No DOMAIN_NAME configured, skipping SSL setup"
            fi

            # Create nginx logs directory if it doesn't exist
            mkdir -p storage/logs/nginx storage/logs/mysql
            touch storage/logs/nginx/access.log storage/logs/nginx/error.log

            # Ensure proper permissions
            sudo chown -R www-data:www-data storage/logs/nginx
            sudo chmod -R 755 storage/logs/nginx
            sudo chmod 644 storage/logs/nginx/access.log storage/logs/nginx/error.log

            # Setup log rotation if not already configured
            if [ ! -f /etc/logrotate.d/nginx-lengofy ]; then
              sudo tee /etc/logrotate.d/nginx-lengofy > /dev/null <<'EOL'
            /var/www/html/storage/logs/nginx/*.log {
                daily
                missingok
                rotate 14
                compress
                delaycompress
                notifempty
                create 0644 www-data www-data
            }
            EOL
            fi

            # Write .env file (no leading spaces - heredoc must be unindented)
            cat > .env <<ENVEOF
            APP_NAME=${{ secrets.APP_NAME }}
            APP_ENV=production
            APP_DEBUG=false
            APP_URL=https://${{ secrets.DOMAIN_NAME }}
            WEBSOCKET_GAME_ENDPOINT=wss://${{ secrets.DOMAIN_NAME }}/ws
            SERVER_NAME=${{ secrets.DOMAIN_NAME }}
            DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}
            DB_CONNECTION=${{ secrets.DB_CONNECTION }}
            DB_HOST=db
            DB_PORT=3306
            DB_DATABASE=${{ secrets.DB_DATABASE }}
            DB_USERNAME=${{ secrets.DB_USERNAME }}
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            DB_ROOT_PASSWORD=${{ secrets.DB_ROOT_PASSWORD }}
            ENVEOF

            # Strip any leading whitespace from .env lines (safety net)
            sed -i 's/^[[:space:]]*//' .env

            # Set proper permissions for .env file
            chmod 644 .env

            # Replace ${SERVER_NAME} in the default.conf
            sed -i "s/\${SERVER_NAME}/${{ secrets.DOMAIN_NAME }}/g" nginx/default.conf

            # Generate APP_KEY before starting containers (using openssl, no PHP needed on host)
            if ! grep -q "^APP_KEY=base64:" .env; then
              echo "Generating APP_KEY..."
              APP_KEY="base64:$(openssl rand -base64 32)"
              echo "APP_KEY=$APP_KEY" >> .env
            fi

            # Docker strategy: only rebuild if needed
            if [ "${{ github.event.inputs.rebuild }}" = "true" ]; then
              echo "Force rebuilding containers..."
              docker compose -f docker-compose.prod.yml down
              docker compose -f docker-compose.prod.yml build --no-cache
            else
              echo "Smart rebuild strategy..."
              if docker images -q lengofy-app:latest 2>/dev/null | grep -q .; then
                echo "Using existing image..."
                docker compose -f docker-compose.prod.yml down
              else
                echo "Building new image..."
                docker compose -f docker-compose.prod.yml build
              fi
            fi

            # Ensure ports 80/443 are free before starting nginx container
            docker compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
            fuser -k 80/tcp 2>/dev/null || true
            fuser -k 443/tcp 2>/dev/null || true

            # Start containers with environment file
            docker compose -f docker-compose.prod.yml --env-file .env up -d

            # Wait for database to be ready
            echo "Waiting for database..."
            timeout 90 bash -c 'until docker exec lengofy-db mysqladmin ping -h localhost --silent 2>/dev/null; do sleep 3; done'

            # Wait for app container to be healthy
            echo "Waiting for app container..."
            timeout 120 bash -c 'until [ "$(docker inspect -f "{{.State.Health.Status}}" lengofy-app 2>/dev/null)" = "healthy" ]; do sleep 5; done' || echo "Warning: app health check timed out, continuing..."

            # Run migrations
            docker exec lengofy-app php artisan migrate --force || true

            # Run seeding only if requested
            if [ "${{ github.event.inputs.seed }}" = "true" ]; then
              docker exec lengofy-app php artisan db:seed --force
            fi

            # Cache optimizations
            docker exec lengofy-app php artisan config:cache
            docker exec lengofy-app php artisan route:cache
            docker exec lengofy-app php artisan view:cache
            docker exec lengofy-app php artisan event:cache
            docker exec lengofy-app php artisan storage:link || true

            # Health check - wait for nginx to be up
            echo "Performing health check..."
            sleep 15

            HEALTH_OK=false
            for i in 1 2 3 4 5; do
              if curl -sf -o /dev/null https://${{ secrets.DOMAIN_NAME }} || curl -sf -o /dev/null http://localhost; then
                HEALTH_OK=true
                break
              fi
              echo "Health check attempt $i failed, retrying in 10s..."
              sleep 10
            done

            if [ "$HEALTH_OK" = "true" ]; then
              echo "✅ Deployment successful!"
            else
              echo "❌ Deployment failed - application not responding"
              echo "--- App logs ---"
              docker compose -f docker-compose.prod.yml logs --tail=30 app
              echo "--- Nginx logs ---"
              docker compose -f docker-compose.prod.yml logs --tail=30 webserver
              exit 1
            fi
